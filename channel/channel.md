##### Channel

```
channel基本用法
· ch<-x  //发送数据x
· x=<-ch //接收数据，赋给x
· <-ch   //接收数据，并丢弃

利用channel的思路
1.看作是队列，主要用于传递数据
2.利用阻塞特性，可以间接控制goroutine或者其他资源的消耗

发布订阅模式
利用channel实现发布订阅模式，发布者不断往channel里面塞入数据，订阅者从channel里面取出数据。
进程内的事件驱动可以依托于channel来实现
缺陷：
1.没有消费组概念。不能说同一个事件被多个gorountine同时消费，有且只能有一个
2.无法回退，也无法随机消费

实现消息队列
例子：利用channel来实现一个基于内存的消息队列，并且有消费组概念。
思路：难点在于channel里面的元素只能被一个gorotine取出来。要想同一个消息能被多goroutine消费
· 方案一：每一个消费者订阅的时候，创建一个子channel
· 方案二：轮询所有的消费者
```
![img.png](img.png)

```
实现一个任务池
例子：利用channel来实现一个任务池。该任务池运行开发者提交任务，
并且设定最多多少个goroutine同时运行。
思路：
 1.提交任务的时候，如果执行goroutine满了，任务池是缓存住这个任务，还是直接阻塞提交者？
 2.如何缓存，那么缓存需要多大？缓存满了又该怎么办？
 
channel与goroutine泄漏
如果goroutine使用不当，就会导致gorountine泄漏：
1.只发送不接受，那么发送着一直阻塞，会导致发送者gorountine泄漏
2.只接受不发送，那么接收者一直阻塞，会导致接收者gorountine泄漏
3.读写nil都会导致gorountine泄漏(不会panic只会阻塞)

唯一的例外是业务层面上gorountine长时间运行

channel与内存逃逸
内存分配
· 分配到栈上：不需要考虑GC
· 分配到堆上：需要考虑GC
 * 如果用channel发送指针，那么必然逃逸。
   编译器无法确定，发送的指针数据最终会被那个goroutine接收！

type hchan struct {
	qcount   uint           
	dataqsiz uint           
	buf      unsafe.Pointer 
	elemsize uint16
	closed   uint32
	elemtype *_type 
	sendx    uint   
	recvx    uint  
	recvq    waitq  
	sendq    waitq  
	lock     mutex
}
1.buf是一个ring buffer结构，用于存储数据
2.waitq是一个双向链表，简单来说就是队列
3.发送的时候，如果缓冲没满，或者有接收者，那么就直接发；否则丢进去sendq
4.接收的时候，如果缓冲有数据，或者有发送者，那就收；否则丢进去recvq

chansend
步骤
1.看是不是nil channel，是的话直接阻塞
2.看有没有被阻塞的接受者，有的话直接交付数据，返回
3.看看缓冲有没有满，没有就放缓冲，返回
4.阻塞，等待接收者来唤醒自己
5.被唤醒，做些清理工作

chanrecv
步骤：
1.看是不是nil channel，是的话直接阻塞
2.看看有没有被阻塞的发送者，有的话直接从发送者手里拿，返回
3.看看缓冲有没有数据，有就读缓冲，返回
4.阻塞，等待发送者来唤醒自己
5.被唤醒，做些清理工作

面试要点
1.channel有buffer和没有buffer有什么特点
2.发送数据都nil channel会怎样？发送到已关闭的channel会怎样？
3.从nil channel接收数据会怎么？从已关闭的channel接受数据会怎么样？
4.channel是怎么引起goroutine泄漏的？
5.channel发送步骤
6.channel接收步骤
7.为什么channel发送指针数据会引起内存泄漏？
8.代码题
  · 用channel实现一个任务池
  · 用channel来控制goroutine数量
  · 用channel来实现生产者-消费者模型  
```


###### Channel发送数据的底层逻辑 

```
Channel发送的情况
1.直接发送
2.放入缓存
3.休眠等待

直接发送(原理)
1.发送数据前，已经有G在休眠等待接收
2.此时缓存肯定是空的，不用考虑缓存
3.将数据直接拷贝给G的结束变量，唤醒G
直接发送(实现)
1.从队列里取出一个等待接收的G
2.将数据直接拷贝到接收变量中
3.唤醒G

放入缓存(原理)
1.没有G在休眠等待，但是有缓存空间
2.将数据放入缓存
放入缓存(实现)
1.获取可存入的缓存地址
2.存入数据
3.维护索引

休眠等待(原理)
1.没有G在休眠等待，而且没有缓存或满了
2.自己进入发送队列，休眠等待
休眠等待(实现)
1.把自己包装成sudog
2.sudug放入sendq队列
3.休眠并解锁
4.被唤醒后，数据已经被取走，维护其他数据

总结
1.直接发送时，将数据直接拷贝到目标变量
2.放入缓存时，将数据放入环形缓存，成功放回
3.休眠等待时，将自己包装后放入sendq，休眠
```

###### Channel接收数据的底层原理

```
Channel接收的情况
1.有等待的G，从G接收
2.有等待的G，从缓存接收
3.接收缓存
4.阻塞接收

有等待的G，从G接收(原理)
1.接受数据前,已经有G在休眠等待发送
2.而且这个Channel没有缓存
3.将数据直接从G拷贝过来，唤醒G
有等待的G，从G接收(实现)
1.判断有G在发送队列等待，进入recv()
2.判断次Channel无缓存
3.直接从等待的G中取走数据，唤醒G

有等待的G，从缓存接收(原理)
1.接收数据前,已经有G在休眠等待发送
2.而且这个Channel有缓存
3.从缓存取走一个数据
4.将休眠G的数据放进缓存,唤醒G
有等待的G，从缓存接收(实现)
1.判断有G在发送队列等待，进入recv()
2.判断此Channel有缓存
3.从缓存中取走一个数据
4.将G的数据放入缓存，唤醒G

接收缓存(原理)
1.没有G在休眠等待发送，但是缓存有内容
2.从缓存取走数据
接收缓存(实现)
1.判断没有G在发送队列等待
2.判断此Channel有缓存
3.从缓存中取走一个数据

阻塞接收(原理)
1.没有G在休眠等待，而且没有缓存或缓存空间
2.自己进入接收队列，休眠等待
阻塞接收(实现)
1.判断没有G在发送队列等待
2.判断此Channel无缓存
3.将自己包装成sudog
4.sudog放入接收等待队列，休眠
5.唤醒时，发送的G已经把数据拷贝到位

总结
1.有等待的G，且无缓存时，从G接收
2.有等待的G，且有缓存时，从缓存接收
3.无等待的G，且缓存有数据，从缓存接收
4.无等待的G，且缓存无数据，等待喂数据
```

